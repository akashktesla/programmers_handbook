\documentclass[12pt]{extarticle}
\usepackage{lmodern} % Required for inserting images
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algorithmic}


\title{Programmer's HandBook}
\author{Akash Tesla}
\date{July 2025}

\begin{document}
\tableofcontents
\newpage
\maketitle

\section*{Graph Theory}
\section{Types of Graphs}
\subsection{Undirected Graph}
A Undirected graph is a graph in which edges have no orientation. the edge (u,v) is identical
to (v,u)

\subsection{Directed Graph(Digraph)}
A directed graph is a graph in which edges have orientation. for example edge (u,v) is the edge
from u to v

\subsection{Weighted Graphs}
Weighted graphs are graphs in which it's edges contains a certain value attributed to certain
value such as cost, distance, quantity, etc... 

\subsection{Tree}
A tree is a an Undirected graph with no cycles. Equivalently it's a connected graph with 
n nodes and n-1 edges

\subsection{Rooted Trees}
A rooted tre is a tree with designated roote node where every edge either ponts away from
or towards the root node. When edges point away from the root node the graph is called 
arborescence or out tree and when the edges point towards the roote node the graph is called
anti-arborescence. 

\subsection{Directed Acyclic Graphs(DAGs)}
Directed Acyclic Graphs are Directed graphs with no cycles. These graphs are commonly used 
in representing structure with dependencies. Several efficient algorithms exist to operate
on DAGS

\subsection{Bipartite Graph}
A Bipartite graph is one whose vertices can be split into two independend group U,V such that
every edge connectes between U and V, and there is no odd cycles

\subsection{Complete Graph}
A complete graph is one where there is a unique edge between every pair of nodes. A complete 
graph with n vertices is denoted as $K_n$

\section{Representing Graphs}

\subsection{Adjacency Matrix}
A adjacency matrix m is a square matrix used to represent a graph. where each row and column
corresponds to a vertex, populate the matrix with condition of  m[from node id][to ndoe id] =
weight of the edge 1 if it is unweighted  \\
Example: 
$$
M = 
\begin{array}{c|ccc}
    & A & B & C \\
\hline
A & 0 & 1 & 0 \\
B & 0 & 0 & 1 \\
C & 1 & 0 & 0 \\
\end{array}
$$

\subsubsection*{Pros}
\begin{itemize}
    \item Space efficient for dense graph
    \item Takes o(n) for look up
\end{itemize}

\subsubsection*{Cons}
\begin{itemize}
    \item Requires $O(v^2)$ space
    \item Requires $O(v^2)$ time to iterate over all edges
    \item where, v is the number of vertices in the graph
\end{itemize}

\subsection{Adjacency List}
A adjacency list represents graphs with a map with key as vertices that stores a list of 
neighbour nodes/ list of edges it connectes to with it's cost if it's weighted \\
Example: {"A":[(C,2),(D,4)],"B":[(A,4),(C,1),(D,7)]}

\subsubsection*{Pros}
\begin{itemize}
    \item Space efficient for sparse graph
    \item Iterating over all edges is efficient
    \item Prefered for traversal 
\end{itemize}

\subsubsection*{Cons}
\begin{itemize}
    \item Edge lookup is O(deg(v))
    \item Not ideal for representing denser graphs
    \item where, v is the number of vertices
    \item deg(v), is the degree of freedom of the vertices aka number of edges connected to it
\end{itemize}

\subsection{Adjacency Map}
A adjacency map represents graphs with a map with key as vertices that stores another map with key 
as edges and value as it's weight \\
Example: {"A":{"C":2,"D":6},B:{"A":7,"C":4}}
\subsection*{Pros}
\begin{itemize}
    \item Edge weight lookup is O(1)
    \item Space efficient for sparse graph
\end{itemize}

\subsection*{Cons}
\begin{itemize}
    \item Space ineffient than adjacency list if you don't want o(1) weight lookup
    \item Not ideal for representing denser graphs
\end{itemize}

\subsection{Edge List}
Edge list represnts graph as list of unordered edges. \\
Example: [(C,A,4),(C,A,1),(B,C,6)]

\section*{Pros}
\begin{itemize}
    \item Space efficient for sparse graphs
    \item Iterating over all edges is efficient
\end{itemize}

\section{Cons}
\begin{itemize}
    \item Less space efficient for denser graphs
    \item Edge weight lookup is O(E)
    \item where, E is number of edges in the graph
\end{itemize}


\section{Graph problems and algorithms used}
\subsection{shortest path problem}
given a weighted graph find the shortest path in the graph \\
Algorithms: BFS,Dijkstra's algorithm, A*, Bellaman-Ford, Floyd-Warshall...

\subsection{Connectivity}
Is there a path between Node A and Node B. \\
Algorithms: union find data structure, Any search algorithms(DFS, BFS)

\subsection{Negative cyles}
Does my weighted graph has a negative cycle if so where, Negative cycles is a path
cycle in which the weights add up to a negative number \\
Algorithms: Bellaman-Ford and Floyd-Warshall

\subsection{Strongly Connected Components}
Strongly conected components are self contained cycles within a directed graph 
where every vertex can reach every other vetex in the same cycle \\
Algorithms:Tarjan's and Kosaraju's algorithm

\subsection{Travelling Salesman Problem (TSP)}
Given a list of cities and the distances between each pairs of cities, what is 
the shortest possible route that visites the city exactly once and returns to 
the origin city, this is an NP-Hard problem
Algorithms: Held-Karp, branch and bound, Ant colony optimizationa and other 
approximation algorithms

\subsubsection{Bridges}
A bridge is an edge in a which graph in which it's removal would increase the 
number of connected components, They could hint at weak points, bottle neck or
or vulnerabilities in a graph 

\subsection{Articulation Points}
An ariticulation point is any node in the graph in which it's removal would increase
the number of connected components, They could hint at weak points, bottle neck or
or vulnerabilities in a graph 

\subsection{Minimum Spanning Tree(MST)}
A Minimum spanning tree is a subset of a connecte, edge-weighted graph that connects
all the vertices together, without any cycles and with minimum possible cost.MSTs are
used in designing a least cost network, circuit design, trasportation networks and etc..\\
Algorithms: Krushkal's, Prim's, Boruvka's algorithm

\subsection{Network flow: Max flow}
With an infinite source how much flow can we push thorough the network consider edges as 
Pipes with water capacity or roards with car capacity.\\
Example: Number of cars that can sustain through the traffic. \\
Algorithms: Ford-Fulkerson, Edmonds-karp, Dinic's algorithm

\section{Graph Algorithms}

\subsection{Dept First Search (DFS)}
DFS works by exploring the deepst part of the network from a starting node, then back tracking
once you hit the dead-end. \\ \\
\textbf{Time complexity} : O(V+E)
\subsubsection{Use cases:} 
\begin{itemize}
    \item Compute a graph's minimum spanning tree
    \item detect and find cycles in an graph
    \item check if the graph is Bipartite
    \item Topologically sort the nodes of a graph 
    \item Find the bridges and articulation points
    \item Generate mazes
    \item Find augumenting paths in a flow network 
\end{itemize}

\subsubsection*{Pseudo code}

\begin{algorithm} [H]
    \caption{Depth First Search (DFS)}
    \begin{algorithmic}[1]
        \STATE \textbf{function} dfs(node, visited, graph)
        \IF{Node is visited}
        \RETURN
        \ENDIF
        \STATE Mark as visited
        \STATE \textit{Problem specific logic goes here}
        \FOR{next in node.neighbours}
        \STATE dfs(next)
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

Either implement logic in the given section or in a seperate function and just call 
the dfs function

\subsection{Breath First Search (BFS)}
A BFS traverses node layer by layer, it starts at some arbitrary node of a graph and explores the neighbours nodes first before moving on to the next level of neighbours, it uses queue to traverse the graph, BFS produces a prev array which can be used to construct
a spanning tree, a tree which connects all the vertices.\\ \\  
\textbf{Time complexity:} O(V+E)

\begin{algorithm}
    \caption {Breath First Search (BFS)}
    \begin{algorithmic}[1]
        \STATE \textbf{function} bfs(node)
        \STATE q.enqueue(node)
        \STATE prev = [null,...,null] of size n
        \WHILE{q is not empty}
        \STATE node = q.dequeue()
        \FOR{next in node.neighbours}
        \IF{next is not visited}
        \STATE q.enqueue(next)
        \STATE Mark as visited
        \STATE prev[next] = node
        \ENDIF
        \ENDFOR
        
        \ENDWHILE
    \end{algorithmic}
\end{algorithm}


\begin{algorithm} [H]
\caption{Reconstruct Path Algorithm}
    \begin{algorithmic}
        \STATE \textbf{function} reconstruct\_path(start,target,prev)
        \STATE current = target
        \STATE prev[start] = null 
        \STATE path = [ ]
        \WHILE{current is not null}
        \STATE path.append(current)
        \STATE current = prev[current]
        \ENDWHILE
        \STATE reverse(path)
        \IF{path[0]==start}
        \RETURN path
        \ELSE
        \RETURN [ ]
        \ENDIF
    \end{algorithmic}
\end{algorithm}

\subsection{Graph theory on grids}
Grids can be represented by a graph where each cell is treated as node, and edge
connect to it's adjacent cells, depending on the problem a node can 4 neighbours 
(up, down, left, right) or 8 neighbours (up, down, left, right and other 4 diagonal
movements). using these rules a graph can be represented in any forms but a better 
way to approach the problem is by using direction vectors, we know by the rule set 
the neighbours of the node can be found by adding 1 in each direction. 

\begin{algorithm} [H]
    \caption{Direction Vectors}
    \begin{algorithmic}[1]
        \STATE dr = [+1,-1,0,0]
        \STATE dc = [0,0,+1,-1]
        \FOR{i=0; i<len(dr); i++}
        \STATE rr = r + dr[i]
        \STATE cc = c + dc[i]
        \IF{rr < 0 or cc > 0 or rr >=R or cc >= C}
        \STATE continue
        \COMMENT{Skip invalid cells}
        \ENDIF
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

\subsection{Topological Ordering}
Topological Ordering is ordering of vertices in directed acyclic graph (DAG) such that
for every edge $u \to v$, u comes before v. It is used to model dependencies like Task 
scheduling or course prerequisites.

\subsubsection*{Topological sort algorithm}
The topological sort algorithm can find the a topological ordering in O(V+E) time.

\begin{algorithm}[H]
    \caption{Topological sort}
    \begin{algorithmic}
    \STATE \textbf{function} top\_sort()
        \STATE N = number of nodes
        \STATE visited = [false]*N
        \STATE post order = []
        \FOR{current = 0; current $<$ N; current++}
        \IF{current is not visited}
        \STATE \COMMENT{Modify the dfs to return the visited nodes}
        \STATE visited nodes = dfs(current, visited, graph) 
        \STATE post order.extend(visited nodes)
        \ENDIF
        \ENDFOR
        \STATE topological order = reverse(post order)
        \RETURN topological order
    \end{algorithmic}
\end{algorithm}


\begin{algorithm} [H]
    \caption{Depth First Search Modified 4 Top sort (DFS)}
    \begin{algorithmic}[1]
        \STATE \textbf{function} dfs(node, visited, graph)
        \STATE visited\_nodes = [ ]
        \IF{Node is visited}
        \RETURN
        \ENDIF
        \STATE Mark as visited
        \FOR{next in node.neighbours}
        \STATE visited\_nodes.extend(dfs(next, visited, graph))
        \ENDFOR
        \STATE visited\_nodes.append(node)
        \RETURN visited\_nodes
    \end{algorithmic}
\end{algorithm}

\subsection{SSSP on DAG}
Single source shortest path on DAG can be solved more efficiently in O(N+E) time 
than in general graphs as on general graph it's an NP-Hard problem. Since DAG
has no cycles, we can exploit the topological ordering of the verticies and make
sure every edge is relaxed once in correct order, relaxed in the sense the accumulated
weight is the lowest. 

\begin{algorithm}[H]
\caption{SSSP on DAG}
\begin{algorithmic}
    \STATE \textbf{function} sssp\_on\_dag(graph, source)
    \STATE N = number of nodes
    \STATE order = top\_sort(graph)
    \STATE dist = [$\infty$]*N
    \STATE dist[source] = 0
    \FOR{u in order}
    \FOR{ (neighbour,weight) in u.neighbours}
    \IF{dist[u]+weight < dist[neighbour]}
    \STATE dist[neighbour] = dist[u] + weight
    \ENDIF
    \ENDFOR
    \ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Dijkstra's shortest path algorithm}
Dijkstra's algorithm is a Single source shortest path algorithm for graph with 
non-negative weights, the algorithm is typically O(E*log(V)) depends on teh data
structures used. 
\subsubsection*{Algorithm Prerequisites}
A constratin for Dijkstra's algorithm is that all edge weights should be non-negative. 
This constratint is imposed to ensure that once a node's been visited it's optimal 
distance cannot be improved. 

\begin{algorithm}[H]
    \caption{Dijkstra's  Algorithm}
\begin{algorithmic}
    \STATE \textbf{function} dijkstra(graph,start)
    \STATE N = number of nodes
    \STATE Visited = [false]*N
    \STATE dist = [$\infty$]*N
    \STATE dist[start] = 0
    \STATE pq = empty priority queue
    \STATE pq.insert((s,0))
    \WHILE {pq.size() != 0}
    \STATE index,minValue = pq.poll()
    \STATE mark index as visited
    \STATE neighbours = graph[index]
    \FOR {neighbour in neighbours}
    \IF {neighbour is visited}
    \STATE \textbf{continue}
    \ENDIF
    \STATE newDist = dist[index] + neighbour.cost
    \IF {newDist < dist[neighbour]}
    \STATE pq.insert((neighbour,newDist))
    \STATE dist[neighbour.to] = newDist
    \ENDIF
    \ENDFOR
    \ENDWHILE
    \RETURN dist
\end{algorithmic}
\end{algorithm}

\subsection{Bellman-Ford Algorithm}
Bellman-Ford algorithm is a single source shortest path (sssp) algorithm. It can find
the shortest path from one node to any other node. It's not an ideal for most sssp Since
it has a time complexity of O(EV). It is used where edge weights have negative values, on 
all other cases Dijkstra's is preffered.

\begin{algorithm}[H]
    \caption{Bellman-Ford Algorithm}
    \begin{algorithmic}
        \STATE \textbf{bellmanFord(graph,start)}
        \STATE N = number of nodes
        \STATE V = number of edges
        \STATE dist = [$\infty$]*N
        \FOR {i=0;i<V-1;i++}
        \FOR{edge in graph.edges}
        \STATE newCost = dist[edge.from]+edge.cost
        \IF{newCost <dist[edge.to]}
        \STATE dist[edge.to] = newCost
        \ENDIF
        \ENDFOR
        \ENDFOR
        \FOR {i=0;i<V-1;i++}
        \FOR{edge in graph.edges}
        \IF{newCost <dist[edge.to]}
        \STATE dist[edge.to] = -$\infty$
        \ENDIF
        \ENDFOR
        \ENDFOR

    \end{algorithmic}
\end{algorithm}



\end{document}
